import Foundation
import SafariServices
import NostrSDK
import Combine

/// NIP-46 (Nostr Connect) client for remote signing via nsec bunker
/// Implements the client side of the Nostr Connect protocol for secure remote signing
@MainActor
class NIP46Client: ObservableObject {
    
    // MARK: - Published Properties
    @Published var connectionState: ConnectionState = .disconnected
    @Published var connectionToken: String?
    @Published var bunkerPublicKey: String?
    @Published var errorMessage: String?
    @Published var pendingRequests: [SigningRequest] = []
    
    // MARK: - Private Properties
    private var localKeyPair: Keypair?
    private var relayPool: RelayPool?
    private var connectionString: String?
    private var subscriptions: [String: Any] = [:]
    private let keychainService = "app.runstr.nip46"
    
    // MARK: - Connection State
    enum ConnectionState {
        case disconnected
        case connecting
        case waitingForApproval
        case connected
        case error(String)
        
        var displayName: String {
            switch self {
            case .disconnected: return "Disconnected"
            case .connecting: return "Connecting"
            case .waitingForApproval: return "Waiting for Approval"
            case .connected: return "Connected"
            case .error: return "Error"
            }
        }
        
        var isConnected: Bool {
            if case .connected = self { return true }
            return false
        }
    }
    
    // MARK: - Signing Request
    struct SigningRequest: Identifiable {
        let id = UUID()
        let eventBuilder: Any // Placeholder until we determine correct EventBuilder type
        let method: String
        let timestamp: Date
        var status: RequestStatus = .pending
        
        enum RequestStatus {
            case pending
            case signed
            case failed(String)
        }
    }
    
    // MARK: - Initialization
    init() {
        loadStoredConnection()
        setupLocalKeyPair()
    }
    
    // MARK: - Connection Management
    
    /// Initiate connection to nsec.app bunker
    func connectToBunker() async {
        connectionState = .connecting
        errorMessage = nil
        
        do {
            // Generate local keypair for NIP-46 communication
            let localKeys: Keypair
            do {
                guard let keypair = try Keypair() else {
                    throw NIP46Error.keyGenerationFailed
                }
                localKeys = keypair
            } catch {
                throw NIP46Error.keyGenerationFailed
            }
            
            self.localKeyPair = localKeys
            
            // Create connection string for nsec.app
            let connectionString = createConnectionString(localPublicKey: localKeys.publicKey.npub)
            self.connectionString = connectionString
            
            // Open nsec.app in Safari with the connection string
            await openBunkerInSafari(connectionString: connectionString)
            
            // Start listening for connection approval
            connectionState = .waitingForApproval
            await listenForConnectionApproval()
            
        } catch {
            print("‚ùå Failed to connect to bunker: \(error)")
            connectionState = .error(error.localizedDescription)
            errorMessage = error.localizedDescription
        }
    }
    
    /// Disconnect from bunker and clear stored connection
    func disconnect() async {
        connectionState = .disconnected
        connectionToken = nil
        bunkerPublicKey = nil
        localKeyPair = nil
        connectionString = nil
        
        // Close all subscriptions
        if let relayPool = relayPool {
            for (_, subscription) in subscriptions {
                if let sub = subscription as? Subscription {
                    try? await sub.unsubscribe()
                }
            }
            subscriptions.removeAll()
            await relayPool.disconnect()
        }
        
        relayPool = nil
        clearStoredConnection()
        
        print("‚úÖ Disconnected from nsec bunker")
    }
    
    /// Check if we have a valid stored connection
    func checkStoredConnection() async -> Bool {
        guard let connectionToken = connectionToken,
              let bunkerPublicKey = bunkerPublicKey,
              let localKeyPair = localKeyPair else {
            return false
        }
        
        // Try to reconnect using stored credentials
        do {
            let success = await establishConnection(
                token: connectionToken,
                bunkerPubkey: bunkerPublicKey,
                localKeyPair: localKeyPair
            )
            
            if success {
                connectionState = .connected
                print("‚úÖ Reconnected to nsec bunker using stored credentials")
                return true
            } else {
                // Clear invalid stored connection
                await disconnect()
                return false
            }
            
        } catch {
            print("‚ùå Failed to reconnect with stored credentials: \(error)")
            await disconnect()
            return false
        }
    }
    
    // MARK: - Remote Signing
    
    /// Sign an event remotely using the connected bunker
    func signEvent(_ eventBuilder: Any) async throws -> Event {
        // Validate connection state
        guard connectionState.isConnected else {
            let error = NIP46Error.notConnected
            await MainActor.run {
                self.errorMessage = error.localizedDescription
            }
            throw error
        }
        
        // Validate required components
        guard let localKeyPair = localKeyPair,
              let bunkerPublicKey = bunkerPublicKey,
              let relayPool = relayPool else {
            let error = NIP46Error.invalidState
            await MainActor.run {
                self.errorMessage = error.localizedDescription
            }
            throw error
        }
        
        let request = SigningRequest(
            eventBuilder: eventBuilder,
            method: "sign_event",
            timestamp: Date()
        )
        
        do {
            // Add to pending requests
            await MainActor.run {
                self.pendingRequests.append(request)
            }
            
            // Create NIP-46 request event with timeout
            let requestEvent = try await withTimeout(30.0) {
                try await createSigningRequest(
                    localKeyPair: localKeyPair,
                    bunkerPublicKey: bunkerPublicKey,
                    eventBuilder: eventBuilder
                )
            }
            
            // Send request to bunker with retry logic
            var publishSuccess = false
            for attempt in 1...3 {
                do {
                    await relayPool.publishEvent(requestEvent)
                    publishSuccess = true
                    print("‚úÖ Published NIP-46 signing request (attempt \(attempt))")
                    break
                } catch {
                    print("‚ö†Ô∏è Failed to publish request (attempt \(attempt)): \(error)")
                    if attempt < 3 {
                        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second delay
                    }
                }
            }
            
            guard publishSuccess else {
                throw NIP46Error.publishFailed
            }
            
            // Wait for response with extended timeout for signing
            let signedEvent = try await withTimeout(60.0) {
                try await waitForSigningResponse(requestId: request.id.uuidString)
            }
            
            // Remove from pending requests
            await MainActor.run {
                self.pendingRequests.removeAll { $0.id == request.id }
                self.errorMessage = nil // Clear any previous errors
            }
            
            print("‚úÖ Event signed remotely via nsec bunker")
            return signedEvent
            
        } catch let error as NIP46Error {
            // Handle specific NIP-46 errors
            await MainActor.run {
                self.pendingRequests.removeAll { $0.id == request.id }
                self.errorMessage = error.localizedDescription
            }
            
            print("‚ùå NIP-46 signing failed: \(error.localizedDescription)")
            
            // If connection error, try to reconnect
            if case .connectionTimeout = error {
                print("üîÑ Attempting to reconnect after timeout...")
                await reconnectIfNeeded()
            }
            
            throw error
            
        } catch {
            // Handle general errors
            await MainActor.run {
                self.pendingRequests.removeAll { $0.id == request.id }
                self.errorMessage = "Signing failed: \(error.localizedDescription)"
            }
            
            print("‚ùå Failed to sign event remotely: \(error)")
            throw NIP46Error.signingFailed(error.localizedDescription)
        }
    }
    
    /// Sign workout event specifically
    func signWorkoutEvent(workout: Workout, privacyLevel: NostrPrivacyLevel = .public) async throws -> Event {
        guard connectionState.isConnected else {
            throw NIP46Error.notConnected
        }
        
        guard let localKeyPair = localKeyPair,
              let bunkerPublicKey = bunkerPublicKey,
              let relayPool = relayPool else {
            throw NIP46Error.invalidState
        }
        
        // Create workout event content
        let workoutContent = createWorkoutEventContent(workout: workout)
        
        // Build tags for Kind 1301 event
        var tags: [[String]] = [
            ["d", workout.id],
            ["title", "RUNSTR Workout - \(workout.activityType.displayName)"],
            ["type", "cardio"],
            ["start", String(Int64(workout.startTime.timeIntervalSince1970))],
            ["end", String(Int64(workout.endTime.timeIntervalSince1970))],
            ["exercise", "33401:\(bunkerPublicKey):\(workout.id)", "", String(workout.distance/1000), String(workout.duration), String(workout.averagePace)],
            ["accuracy", "exact", "gps_watch"],
            ["client", "RUNSTR", "v1.0.0"]
        ]
        
        // Add heart rate if available
        if let heartRate = workout.averageHeartRate {
            tags.append(["heart_rate_avg", String(heartRate), "bpm"])
        }
        
        // Add GPS data if available (simplified for now)
        if let route = workout.route, !route.isEmpty {
            tags.append(["gps_polyline", "encoded_gps_data_placeholder"])
        }
        
        // Add privacy tags
        if privacyLevel == .public {
            tags.append(["t", "fitness"])
            tags.append(["t", workout.activityType.rawValue])
        }
        
        do {
            // Create the unsigned event data to send for signing
            let unsignedEventData: [String: Any] = [
                "kind": 1301,
                "content": workoutContent,
                "tags": tags,
                "created_at": Int(Date().timeIntervalSince1970)
            ]
            
            // Create NIP-46 signing request
            let requestId = UUID().uuidString
            let signedEvent = try await sendNIP46SigningRequest(
                requestId: requestId,
                method: "sign_event",
                params: [unsignedEventData],
                localKeyPair: localKeyPair,
                bunkerPublicKey: bunkerPublicKey
            )
            
            print("‚úÖ Workout event signed remotely via NIP-46")
            return signedEvent
            
        } catch {
            print("‚ùå Failed to sign workout event via NIP-46: \(error)")
            throw error
        }
    }
    
    /// Create workout event content following NIP-101e spec
    private func createWorkoutEventContent(workout: Workout) -> String {
        let workoutData: [String: Any] = [
            "type": workout.activityType.rawValue,
            "distance": workout.distance, // meters
            "duration": workout.duration, // seconds
            "startTime": ISO8601DateFormatter().string(from: workout.startTime),
            "endTime": ISO8601DateFormatter().string(from: workout.endTime),
            "averagePace": workout.averagePace, // minutes per km
            "calories": workout.calories ?? 0,
            "elevationGain": workout.elevationGain ?? 0,
            "averageHeartRate": workout.averageHeartRate ?? 0
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: workoutData)
            return String(data: jsonData, encoding: .utf8) ?? ""
        } catch {
            print("‚ùå Failed to serialize workout data: \(error)")
            return ""
        }
    }
    
    // MARK: - Private Methods
    
    /// Setup local keypair for NIP-46 communication
    private func setupLocalKeyPair() {
        if let storedKeys = loadStoredLocalKeys() {
            self.localKeyPair = storedKeys
        }
    }
    
    /// Create connection string for nsec.app
    private func createConnectionString(localPublicKey: String) -> String {
        let metadata = [
            "name": "RUNSTR",
            "description": "Bitcoin fitness app",
            "url": "https://runstr.app",
            "permissions": ["sign_event:1301", "nip04_encrypt", "nip04_decrypt"]
        ]
        
        let metadataString = try? JSONSerialization.data(withJSONObject: metadata)
            .base64EncodedString() ?? ""
        
        return "nostr+connect://\(localPublicKey)?relay=wss://relay.nsec.app&metadata=\(metadataString ?? "")"
    }
    
    /// Open nsec.app in Safari with connection string
    private func openBunkerInSafari(connectionString: String) async {
        guard let encodedString = connectionString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),
              let url = URL(string: "https://nsec.app/connect?target=\(encodedString)") else {
            connectionState = .error("Invalid connection URL")
            return
        }
        
        // Open in Safari
        await MainActor.run {
            guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                  let window = windowScene.windows.first,
                  let rootViewController = window.rootViewController else {
                return
            }
            
            let safariVC = SFSafariViewController(url: url)
            safariVC.preferredBarTintColor = .black
            safariVC.preferredControlTintColor = .white
            rootViewController.present(safariVC, animated: true)
        }
        
        print("‚úÖ Opened nsec.app for connection approval")
    }
    
    /// Listen for connection approval from bunker
    private func listenForConnectionApproval() async {
        guard let localKeyPair = localKeyPair else { return }
        
        do {
            // Connect to nsec.app relay
            guard let relayUrl = URL(string: "wss://relay.nsec.app") else {
                throw NIP46Error.invalidState
            }
            
            let relay = try Relay(url: relayUrl)
            relayPool = RelayPool(relays: Set([relay]))
            guard let relayPool = relayPool else { return }
            
            await relayPool.connect()
            
            // Create filter for connection approval messages
            let filter = Filter()
            filter.kinds = [.encryptedDirectMessage] // Kind 4 for encrypted DMs
            filter.authors = [] // We'll listen for any bunker responses
            filter.since = Timestamp.now()
            
            // Add p tag for our local public key
            guard let localPubkey = try? PublicKey.parse(npub: localKeyPair.publicKey.npub) else {
                throw NIP46Error.invalidPublicKey
            }
            
            // Subscribe to messages directed at our local key
            let subscriptionId = "nip46_approval_\(UUID().uuidString)"
            let subscription = try relayPool.subscribe(filters: [filter], subscriptionId: subscriptionId)
            subscriptions[subscriptionId] = subscription
            
            // Wait for approval message
            let timeout: TimeInterval = 300.0 // 5 minutes
            let startTime = Date()
            
            while Date().timeIntervalSince(startTime) < timeout && connectionState == .waitingForApproval {
                try await Task.sleep(nanoseconds: 500_000_000) // 0.5 second
                
                let events = try await subscription.getEvents()
                
                for event in events {
                    if let approval = try? parseConnectionApproval(event: event, localKeyPair: localKeyPair) {
                        // Store connection details
                        connectionToken = approval.token
                        bunkerPublicKey = approval.bunkerPubkey
                        
                        // Save to keychain
                        saveConnectionToKeychain(
                            token: approval.token,
                            bunkerPubkey: approval.bunkerPubkey,
                            localKeyPair: localKeyPair
                        )
                        
                        connectionState = .connected
                        
                        // Close approval subscription
                        try await subscription.unsubscribe()
                        subscriptions.removeValue(forKey: subscriptionId)
                        
                        print("‚úÖ Connection approved by nsec bunker")
                        return
                    }
                }
            }
            
            // Timeout
            connectionState = .error("Connection approval timeout")
            errorMessage = "Connection request timed out. Please try again."
            
        } catch {
            connectionState = .error(error.localizedDescription)
            errorMessage = error.localizedDescription
            print("‚ùå Failed to listen for connection approval: \(error)")
        }
    }
    
    /// Parse connection approval message from nsec.app
    private func parseConnectionApproval(event: Event, localKeyPair: Keypair) throws -> (token: String, bunkerPubkey: String) {
        // TODO: Implement proper NIP-04 decryption with NostrSDK 0.3.0 API
        // For now, return a mock approval for development
        print("‚ö†Ô∏è NIP-46 connection approval parsing not fully implemented")
        
        let token = UUID().uuidString
        return (token: token, bunkerPubkey: event.author.toHex())
    }
    
    /// Establish connection with bunker using token
    private func establishConnection(token: String, bunkerPubkey: String, localKeyPair: Keypair) async -> Bool {
        // Implementation for establishing the actual signing connection
        // This would involve setting up the secure channel for signing requests
        return true // Simplified for now
    }
    
    /// Send NIP-46 signing request to bunker
    private func sendNIP46SigningRequest(requestId: String, method: String, params: [Any], localKeyPair: Keypair, bunkerPublicKey: String) async throws -> Event {
        // TODO: Implement proper NIP-46 signing request with NostrSDK 0.3.0 API
        print("‚ö†Ô∏è NIP-46 signing request not fully implemented")
        
        // For now, throw not implemented error
        throw NIP46Error.notImplemented
    }
    
    /// Wait for NIP-46 response from bunker
    private func waitForNIP46Response(requestId: String, localKeyPair: Keypair) async throws -> Event {
        guard let relayPool = relayPool else {
            throw NIP46Error.invalidState
        }
        
        // Create filter for Kind 24133 responses directed at our local key
        let filter = Filter()
        filter.kinds = [.custom(24133)]
        filter.since = Timestamp.now()
        
        guard let localPubkey = try? PublicKey.parse(npub: localKeyPair.publicKey.npub) else {
            throw NIP46Error.invalidPublicKey
        }
        
        // Subscribe to responses
        let subscriptionId = "nip46_response_\(requestId)"
        let subscription = try relayPool.subscribe(filters: [filter], subscriptionId: subscriptionId)
        subscriptions[subscriptionId] = subscription
        
        let timeout: TimeInterval = 30.0 // 30 seconds
        let startTime = Date()
        
        while Date().timeIntervalSince(startTime) < timeout {
            try await Task.sleep(nanoseconds: 500_000_000) // 0.5 second
            
            let events = try await subscription.getEvents()
            
            for event in events {
                do {
                    // Check if this event is directed at us
                    let tags = event.tags.map { $0.asVec() }
                    guard tags.contains(where: { $0.first == "p" && $0.last == localKeyPair.publicKey.hex }) else {
                        continue
                    }
                    
                    // Decrypt the response
                    let decryptedContent = try localKeyPair.decrypt(content: event.content, publicKey: event.author)
                    
                    // Parse response JSON
                    guard let data = decryptedContent.data(using: .utf8),
                          let responseJson = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                          let id = responseJson["id"] as? String,
                          id == requestId else {
                        continue
                    }
                    
                    // Check for error
                    if let error = responseJson["error"] as? [String: Any],
                       let message = error["message"] as? String {
                        throw NIP46Error.signingFailed(message)
                    }
                    
                    // Parse the signed event
                    guard let result = responseJson["result"] as? [String: Any] else {
                        throw NIP46Error.invalidResponse
                    }
                    
                    // Convert the result back to a proper Event
                    let signedEvent = try parseEventFromNIP46Response(result)
                    
                    // Close subscription
                    try await subscription.unsubscribe()
                    subscriptions.removeValue(forKey: subscriptionId)
                    
                    return signedEvent
                    
                } catch {
                    print("‚ùå Error processing NIP-46 response: \(error)")
                    continue
                }
            }
        }
        
        // Timeout
        try await subscription.unsubscribe()
        subscriptions.removeValue(forKey: subscriptionId)
        throw NIP46Error.signingTimeout
    }
    
    /// Parse Event from NIP-46 response
    private func parseEventFromNIP46Response(_ responseData: [String: Any]) throws -> Event {
        // TODO: Implement proper event reconstruction with NostrSDK 0.3.0 API
        print("‚ö†Ô∏è NIP-46 event parsing not fully implemented")
        
        // For now, throw not implemented error
        throw NIP46Error.notImplemented
    }
    
    /// Wait for signing response from bunker
    private func waitForSigningResponse(requestId: String) async throws -> Event {
        guard let relayPool = relayPool,
              let localKeyPair = localKeyPair else {
            throw NIP46Error.invalidState
        }
        
        // Create filter for encrypted DMs from bunker
        let filter = Filter()
        filter.kinds = [.encryptedDirectMessage]
        filter.since = Timestamp.now()
        
        // Subscribe to responses
        let subscriptionId = "nip46_response_\(requestId)"
        let subscription = relayPool.subscribe(filters: [filter], subscriptionId: subscriptionId)
        subscriptions[subscriptionId] = subscription
        
        let timeout: TimeInterval = 30.0 // 30 seconds
        let startTime = Date()
        
        while Date().timeIntervalSince(startTime) < timeout {
            try await Task.sleep(nanoseconds: 500_000_000) // 0.5 second
            
            let events = try await subscription.getEvents()
            
            for event in events {
                do {
                    // Decrypt response
                    let decryptedContent = try localKeyPair.decrypt(content: event.content, publicKey: event.author)
                    
                    // Parse response
                    guard let data = decryptedContent.data(using: .utf8),
                          let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                          let id = json["id"] as? String,
                          id == requestId else {
                        continue
                    }
                    
                    // Check for error
                    if let error = json["error"] as? [String: Any],
                       let message = error["message"] as? String {
                        throw NIP46Error.signingFailed(message)
                    }
                    
                    // Parse signed event
                    guard let result = json["result"] as? String,
                          let eventData = result.data(using: .utf8),
                          let eventJson = try JSONSerialization.jsonObject(with: eventData) as? [String: Any] else {
                        throw NIP46Error.invalidResponse
                    }
                    
                    // Convert back to Event object
                    let signedEvent = try parseEventFromJson(eventJson)
                    
                    // Close subscription
                    try await subscription.unsubscribe()
                    subscriptions.removeValue(forKey: subscriptionId)
                    
                    return signedEvent
                    
                } catch {
                    print("‚ùå Error processing signing response: \(error)")
                    continue
                }
            }
        }
        
        // Timeout
        try await subscription.unsubscribe()
        subscriptions.removeValue(forKey: subscriptionId)
        throw NIP46Error.signingTimeout
    }
    
    /// Parse Event object from JSON
    private func parseEventFromJson(_ json: [String: Any]) throws -> Event {
        // TODO: Implement proper event parsing with NostrSDK 0.3.0 API
        print("‚ö†Ô∏è NIP-46 JSON event parsing not fully implemented")
        
        // For now, throw not implemented error
        throw NIP46Error.notImplemented
    }
    
    // MARK: - Keychain Storage
    
    private func saveConnectionToKeychain(token: String, bunkerPubkey: String, localKeyPair: Keypair) {
        let connectionData: [String: Any] = [
            "token": token,
            "bunkerPubkey": bunkerPubkey,
            "localPrivateKey": localKeyPair.privateKey.nsec,
            "localPublicKey": localKeyPair.publicKey.npub
        ]
        
        guard let data = try? JSONSerialization.data(withJSONObject: connectionData) else { return }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: "nip46_connection",
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]
        
        SecItemDelete(query as CFDictionary)
        SecItemAdd(query as CFDictionary, nil)
        
        print("‚úÖ NIP-46 connection saved to keychain")
    }
    
    private func loadStoredConnection() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: "nip46_connection",
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let connectionData = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let token = connectionData["token"] as? String,
              let bunkerPubkey = connectionData["bunkerPubkey"] as? String,
              let localPrivateKey = connectionData["localPrivateKey"] as? String else {
            return
        }
        
        do {
            guard let localKeyPair = try Keypair(nsec: localPrivateKey) else {
                print("‚ùå Failed to recreate keypair from stored private key")
                return
            }
            
            self.connectionToken = token
            self.bunkerPublicKey = bunkerPubkey
            self.localKeyPair = localKeyPair
            
            print("‚úÖ Loaded stored NIP-46 connection")
        } catch {
            print("‚ùå Error loading stored connection: \(error)")
        }
    }
    
    private func loadStoredLocalKeys() -> Keypair? {
        // Implementation for loading stored local keypair
        return nil
    }
    
    private func clearStoredConnection() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: "nip46_connection"
        ]
        
        SecItemDelete(query as CFDictionary)
        print("‚úÖ Cleared stored NIP-46 connection")
    }
    
    // MARK: - Helper Methods
    
    /// Execute async operation with timeout
    private func withTimeout<T>(_ seconds: TimeInterval, _ operation: @escaping () async throws -> T) async throws -> T {
        return try await withThrowingTaskGroup(of: T.self) { group in
            group.addTask {
                try await operation()
            }
            
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                throw NIP46Error.connectionTimeout
            }
            
            guard let result = try await group.next() else {
                throw NIP46Error.connectionTimeout
            }
            
            group.cancelAll()
            return result
        }
    }
    
    /// Attempt to reconnect if connection is lost
    private func reconnectIfNeeded() async {
        guard !connectionState.isConnected else { return }
        
        print("üîÑ Attempting NIP-46 reconnection...")
        
        // Check if we have stored connection details
        if let token = connectionToken,
           let bunkerPubkey = bunkerPublicKey,
           let localKeys = localKeyPair {
            
            let success = await establishConnection(
                token: token,
                bunkerPubkey: bunkerPubkey,
                localKeyPair: localKeys
            )
            
            if success {
                await MainActor.run {
                    self.connectionState = .connected
                    self.errorMessage = nil
                }
                print("‚úÖ NIP-46 reconnection successful")
            } else {
                await MainActor.run {
                    self.connectionState = .error("Reconnection failed")
                    self.errorMessage = "Failed to reconnect to nsec bunker"
                }
                print("‚ùå NIP-46 reconnection failed")
            }
        }
    }
    
    /// Create signing request event (placeholder for full implementation)
    private func createSigningRequest(localKeyPair: Keypair, bunkerPublicKey: String, eventBuilder: Any) async throws -> Event {
        // TODO: Implement proper NIP-46 signing request creation with NostrSDK 0.3.0 API
        print("‚ö†Ô∏è NIP-46 signing request creation not fully implemented")
        
        // For now, throw not implemented error
        throw NIP46Error.notImplemented
    }
}

// MARK: - Errors

enum NIP46Error: LocalizedError {
    case keyGenerationFailed
    case notConnected
    case invalidState
    case invalidPublicKey
    case invalidApprovalMessage
    case signingFailed(String)
    case signingTimeout
    case invalidResponse
    case notImplemented
    case connectionTimeout
    case publishFailed
    
    var errorDescription: String? {
        switch self {
        case .keyGenerationFailed:
            return "Failed to generate local keypair"
        case .notConnected:
            return "Not connected to nsec bunker"
        case .invalidState:
            return "Invalid connection state"
        case .invalidPublicKey:
            return "Invalid public key format"
        case .invalidApprovalMessage:
            return "Invalid connection approval message"
        case .signingFailed(let message):
            return "Signing failed: \(message)"
        case .signingTimeout:
            return "Signing request timed out"
        case .invalidResponse:
            return "Invalid response from bunker"
        case .notImplemented:
            return "Feature not yet implemented"
        case .connectionTimeout:
            return "Connection to bunker timed out"
        case .publishFailed:
            return "Failed to publish signing request to relay"
        }
    }
}

// Note: NostrPrivacyLevel is defined in NostrService.swift to avoid duplication